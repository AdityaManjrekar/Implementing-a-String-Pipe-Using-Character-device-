# Implementing-a-String-Pipe-Using-Character-device-
Objective You will implement a kernel-level pipe for exchanging strings among user-level processes. You will learn about concurrency, synchronization, and various kernel primitives. Problem Statement This is a classical producer-consumer problem. Implement a miscellaneous character device in the Linux Kernel. This device must maintain a FIFO queue (i.e. a pipe) of maximum N strings (configured as a module parameter).      In user space, there are several concurrent processes that are consumers and producers of strings.     Producers produce strings and write them to a character device (say /dev/mypipe).     Consumers read the strings from the character device and print it on the screen.     When the pipe is full, i.e. when there are N strings stored in character device, then any producer trying to write will block.     When the pipe is empty, i.e. when there are 0 strings stored in character device, then any consumer trying to read will block.     When a consumer reads from a (full) pipe, it wakes up all blocked producers. In this case, no blocked consumer should be woken up.     When a producer writes to a (empty) pipe, it wakes up all blocked consumers. In this case, no blocked producer should be woken up. 
